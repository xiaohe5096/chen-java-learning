在Java中，有两种方式实现定时任务：
- 使用java.util包中的Timer和TimerTask
- 使用Java并发包中的ScheduledExecutorService

它们的基本用法都是比较简单的，但如果对它们没有足够的了解，则很容易陷入其中的一些陷阱。

## 1.Timer和TimerTask
#### 1.1.基本用法
TimerTask表示一个定时任务，它是一个抽象类，实现了Runnable，具体的定时任务需要继承该类，实现run方法。Timer是一个具体类，它负责定时任务的调度和执行。

需要注意固定延时(fixed-delay)与固定频率(fixed-rate)的区别，都是重复执行，但后一次任务执行相对的时间是不一样的，对于固定延时，它是基于上次任务的"实际"执行时间来算的，如果由于某种原因，上次任务延时了，则本次任务也会延时，而固定频率会尽量补够运行次数。

另外，需要注意的是，如果第一次计划执行的时间firstTime是一个过去的时间，则任务会立即运行，对于固定延时的任务，下次任务会基于第一次执行时间计算，而对于固定频率的任务，则会从firstTime开始算，有可能加上period后还是一个过去时间，从而连续运行很多次，直到时间超过当前时间。

#### 1.2.基本原理
Timer内部主要由两部分组成，任务队列和Timer线程。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。Timer线程负责执行所有的定时任务，需要强调的是，一个Timer对象只有一个Timer线程。

Timer线程主体是一个循环，从队列中拿任务，如果队列中有任务且计划执行时间小于等于当前时间，就执行它，如果队列中没有任务或第一个任务延时还没到，就睡眠。如果睡眠过程中队列上添加了新任务且新任务是第一个任务，Timer线程会被唤醒，重新进行检查。

在执行任务之前，Timer线程判断任务是否为周期任务，如果是，就设置下次执行的时间并添加到优先级队列中，对于固定延时的任务，下次执行时间为当前时间加上period，对于固定频率的任务，下次执行时间为上次计划执行时间加上period。

需要强调是，下次任务的计划是在执行当前任务之前就做出了的，对于固定延时的任务，延时相对的是任务执行前的当前时间，而不是任务执行后，这与ScheduledExecutorService的固定延时计算方法是不同的，后者的计算方法更合乎一般的期望。

另一方面，对于固定频率的任务，它总是基于最先的计划计划的，所以，很有可能会出现一下子执行很多次任务的情况。

#### 1.3.死循环
一个Timer对象只有一个Timer线程，这意味着，定时任务不能耗时太长，更不能是无限循环，否则其后的定时任务将永远没有机会执行。

#### 1.4.异常处理
关于Timer线程，还需要强调非常重要的一点，在执行任何一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有定时任务都会被取消。

所以，如果希望各个定时任务不互相干扰，一定要在run方法内捕获所有异常。

#### 1.5.小结
Timer/TimerTask的基本使用是比较简单的，但我们需要注意：
- 背后只有一个线程在运行
- 固定频率的任务被延迟后，可能会立即执行多次，将次数补够
- 固定延时任务的延时相对的是任务执行前的时间
- 不要在定时任务中使用无限循环
- 一个定时任务的未处理异常会导致所有定时任务被取消

## 2.ScheduledExecutorService   
#### 2.1.接口和类定义
由于Timer/TimerTask的一些问题，Java并发包引入了ScheduledExecutorService，它是一个接口，其定义的方法的大部分语义与Timer中的基本是类似的。

对于固定频率的任务，第一次执行时间为initialDelay后，第二次为initialDelay+period，第三次initialDelay+2*period，依次类推。不过，对于固定延时的任务，它是从任务执行后开始算的，第一次为initialDelay后，第二次为第一次任务执行结束后再加上delay。与Timer不同，它不支持以绝对时间作为首次运行的时间。

ScheduledExecutorService的主要实现类是ScheduledThreadPoolExecutor，它是线程池ThreadPoolExecutor的子类，是基于线程池实现的。它的任务队列是一个无界的优先级队列，所以最大线程数对它没有作用，即使corePoolSize设为0，它也会至少运行一个线程。

工厂类Executors也提供了一些方便的方法，以方便创建ScheduledThreadPoolExecutor。

由于可以有多个线程执行定时任务，一般任务就不会被某个长时间运行的任务所延迟了。另外，与Timer不同，单个定时任务的异常不会再导致整个定时任务被取消了，即使背后只有一个线程执行任务。

#### 2.2.基本原理
ScheduledThreadPoolExecutor的实现思路与Timer基本是类似的，都有一个基于堆的优先级队列，保存待执行的定时任务，它的主要不同是：
- 它的背后是线程池，可以有多个线程执行任务
- 它在任务执行后再设置下次执行的时间，对于固定延时的任务更为合理
- 任务执行线程会捕获任务执行过程中的所有异常，一个定时任务的异常不会影响其他定时任务，但发生异常的任务也不再被重新调度，即使它是一个重复任务