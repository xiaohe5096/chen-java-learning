## 1.创建线程
线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。在Java中创建线程有两种方式，一种是继承Thread，另外一种是实现Runnable接口。

## 2.线程的基本属性和方法
#### 2.1.id和name
每个线程都有一个id和name，id是一个递增的整数，每创建一个线程就加一，name的默认值是"Thread-"后跟一个编号，给Thread设置一个友好的名字，可以方便调试。

#### 2.2.优先级
线程有一个优先级的概念，在Java中，优先级从1到10，默认为5。优先级对操作系统而言更多的是一种建议和提示，而非强制，简单的说，在编程中，不要过于依赖优先级。

#### 2.3.状态
线程的状态包括：
- NEW: 没有调用start的线程状态为NEW
- TERMINATED: 线程运行结束后状态为TERMINATED
- RUNNABLE: 调用start后线程在执行run方法且没有阻塞时状态为RUNNABLE，不过，RUNNABLE不代表CPU一定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只是它没有在等待其他条件
- BLOCKED：当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为BLOCKED
- WAITING、TIMED_WAITING：当前线程调用 `wait()` 方法时，会放入条件等待队列，阻塞等待，线程状态变为WAITING或TIMED_WAITING

Thread还有一个方法 `isAlive()` ，返回线程是否活着，线程被启动后，run方法运行结束前，返回值都是true。

#### 2.4.是否daemon线程
Thread有一个是否daemon线程的属性，daemon线程一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。即使我们运行一个最简单的Java程序，除了main线程外，至少还有一个负责垃圾回收的线程，这个线程就是daemon线程，在main线程结束的时候，垃圾回收线程也会退出。

#### 2.5.sleep方法
Thread有一个静态的sleep方法，调用该方法会让当前线程睡眠指定的时间，睡眠期间，该线程会让出CPU。睡眠期间，线程可以被中断，如果被中断，sleep会抛出InterruptedException。

#### 2.6.yield方法
Thread还有一个让出CPU的方法：`yield()`，调用该方法，是告诉操作系统的调度器，我现在不着急占用CPU，你可以先让其他线程运行。不过，这对调度器也仅仅是建议，调度器如何处理是不一定的，它可能完全忽略该调用。

#### 2.7.join方法
Thread有一个join方法，可以让调用join的线程等待该线程结束，在等待线程结束的过程中，这个等待可能被中断，如果被中断，会抛出InterruptedException。

#### 2.8.过时方法
Thread类中还有一些看上去可以控制线程生命周期的方法，如：`stop()`、`suspend()`、`resume()`，这些方法因为各种原因已被标记为了过时，我们不应该在程序中使用它们。

## 3.共享内存及问题
#### 3.1.共享内存
每个线程表示一条单独的执行流，有自己的程序计数器，有自己的栈，但线程之间可以共享内存，它们可以访问和操作相同的对象。当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果。

#### 3.2.竞态条件
所谓竞态条件(race condition)是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。

怎么解决这个问题呢？有多种方法：
- 使用synchronized关键字
- 使用显式锁
- 使用原子变量 

#### 3.3.内存可见性
多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到，这就是内存可见性问题。

在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，而稍后才会同步更新到内存中。在单线程的程序中，这一般不是个问题，但在多线程的程序中，尤其是在有多CPU的情况下，这就是个严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。

怎么解决这个问题呢？有多种方法：
- 使用volatile关键字
- 使用synchronized关键字或显式锁同步 

## 4.线程的优点及成本
#### 4.1.优点
- 充分利用多CPU的计算能力，单线程只能利用一个CPU，使用多线程可以利用多CPU的计算能力。
- 充分利用硬件资源，CPU和硬盘、网络是可以同时工作的，一个线程在等待网络IO的同时，另一个线程完全可以利用CPU，对于多个独立的网络请求，完全可以使用多个线程同时请求。
- 在用户界面(GUI)应用程序中，保持程序的响应性，界面和后台任务通常是不同的线程，否则，如果所有事情都是一个线程来执行，当执行一个很慢的任务时，整个界面将停止响应，也无法取消该任务。
- 简化建模及IO处理，比如，在服务器应用程序中，对每个用户请求使用一个单独的线程进行处理，相比使用一个线程，处理来自各种用户的各种请求，以及各种网络和文件IO事件，建模和编写程序要容易的多。

#### 4.2.成本
- 创建线程需要消耗操作系统的资源，操作系统会为每个线程创建必要的数据结构、栈、程序计数器等，创建也需要一定的时间。
- 线程调度和切换也是有成本的，当有当量可运行线程的时候，操作系统会忙于调度，为一个线程分配一段时间，执行完后，再让另一个线程执行，一个线程被切换出去后，操作系统需要保存它的当前上下文状态到内存，上下文状态包括当前CPU寄存器的值、程序计数器的值等，而一个线程被切换回来后，操作系统需要恢复它原来的上下文状态，整个过程被称为上下文切换，这个切换不仅耗时，而且使CPU中的很多缓存失效，是有成本的。
- 如果执行的任务都是CPU密集型的，即主要消耗的都是CPU，那创建超过CPU数量的线程就是没有必要的，并不会加快程序的执行。