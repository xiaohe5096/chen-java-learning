## 1.用法
synchronized可以用于修饰类的实例方法、静态方法和代码块。
#### 1.1.实例方法
synchronized实例方法实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行。再具体来说，synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，执行synchronized实例方法的过程大概如下：
- 尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒
- 执行实例方法体代码
- 释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性

当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为BLOCKED。

synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。

此外，synchronized方法不能防止非synchronized方法被同时执行。

#### 1.2.静态方法
synchronized同样可以用于静态方法，对实例方法，保护的是当前实例对象this，而对静态方法，保护的是类对象。

synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以同时，一个执行synchronized静态方法，另一个执行synchronized实例方法。

#### 1.3.代码块
除了用于修饰方法外，synchronized还可以用于包装代码块，synchronized括号里面的就是保护的对象，{}里面是同步执行的代码。

synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。

## 2.理解synchronized
#### 2.1.可重入性
synchronized有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用，比如说，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。

可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。

#### 2.2.内存可见性
synchronized除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。

不过，如果只是为了保证内存可见性，使用synchronzied的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符volatile。加了volatile之后，Java会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。

#### 2.3.死锁
使用synchronized或者其他锁，要注意死锁，所谓死锁就是类似这种现象，比如， 有a, b两个线程，a持有锁A，在等待锁B，而b持有锁B，在等待锁A，a,b陷入了互相等待，最后谁都执行不下去。

怎么解决呢？首先，应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。

还有一种方法是使用显式锁接口Lock，它支持尝试获取锁(tryLock)和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。

如果还是出现了死锁，怎么办呢？Java不会主动处理，不过，借助一些工具，我们可以发现运行中的死锁，比如，Java自带的jstack命令会报告发现的死锁。

## 3.同步容器及其注意事项
#### 3.1.同步容器
Collections的一些方法，它们可以返回线程安全的同步容器，比如：`synchronizedCollection`、`synchronizedList`、`synchronizedMap`。它们是给所有容器方法都加上synchronized来实现安全的。

加了synchronized，所有方法调用变成了原子操作，然而也并不是绝对安全的，至少有以下情况需要注意：
- 复合操作，比如先检查再更新
- 伪同步
- 迭代

#### 3.2.复合操作
```
public class EnhancedMap <K, V> {
    Map<K, V> map;
    
    public EnhancedMap(Map<K,V> map){
        this.map = Collections.synchronizedMap(map);
    }
    
    public V putIfAbsent(K key, V value){
         V old = map.get(key);
         if(old!=null){
             return old;
         }
         map.put(key, value);
         return null;
     }
    
    public void put(K key, V value){
        map.put(key, value);
    }
    
    //... 其他代码
}
```
EnhancedMap是一个装饰类，接受一个Map对象，调用synchronizedMap转换为了同步容器对象map，增加了一个方法putIfAbsent，该方法只有在原Map中没有对应键的时候才添加。

map的每个方法都是安全的，但这个复合方法putIfAbsent不是安全的。这是一个检查然后再更新的复合操作，在多线程的情况下，可能有多个线程都执行完了检查这一步，都发现Map中没有对应的键，然后就会都调用put，而这就破坏了putIfAbsent方法期望保持的语义。

#### 3.3.伪同步
那给该方法加上synchronized就能实现安全吗，答案是否定的。因为同步错对象了，putIfAbsent同步使用的是EnhancedMap对象，而其他方法(如代码中的put方法)使用的是Collections.synchronizedMap返回的对象map，两者是不同的对象。要解决这个问题，所有方法必须使用相同的锁，可以使用EnhancedMap的对象锁，也可以使用map。使用EnhancedMap对象作为锁，则EnhancedMap中的所有方法都需要加上synchronized。使用map作为锁，putIfAbsent方法可以改为：
```
public V putIfAbsent(K key, V value){
    synchronized(map){
        V old = map.get(key);
         if(old!=null){
             return old;
         }
         map.put(key, value);
         return null;    
    }
}
```

#### 3.4.迭代
对于同步容器对象，虽然单个操作是安全的，但迭代并不是。如果在遍历的同时容器发生了结构性变化，就会抛出ConcurrentModificationException，如果要避免这个异常，需要在遍历的时候给整个容器对象加锁。

#### 3.5.并发容器
除了以上这些注意事项，同步容器的性能也是比较低的，当并发访问量比较大的时候性能很差。所幸的是，Java中有很多专为并发设计的容器类，比如：`CopyOnWriteArrayList`、`ConcurrentHashMap`等。这些容器类都是线程安全的，但都没有使用synchronized、没有迭代问题、直接支持一些复合操作、性能也高得多。