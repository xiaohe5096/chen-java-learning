## 1.取消/关闭的场景
我们知道，通过线程的start方法启动一个线程后，线程开始执行run方法，run方法运行结束后线程退出，那为什么还需要结束一个线程呢？有多种情况，比如说：
- 很多线程的运行模式是死循环，比如在生产者/消费者模式中，消费者主体就是一个死循环，它不停的从队列中接受任务，执行任务，在停止程序时，我们需要一种"优雅"的方法以关闭该线程。
- 在一些图形用户界面程序中，线程是用户启动的，完成一些任务，比如从远程服务器上下载一个文件，在下载过程中，用户可能会希望取消该任务。
- 在一些场景中，比如从第三方服务器查询一个结果，我们希望在限定的时间内得到结果，如果得不到，我们会希望取消该任务。
- 有时，我们会启动多个线程做同一件事，比如类似抢火车票，我们可能会让多个好友帮忙从多个渠道买火车票，只要有一个渠道买到了，我们会通知取消其他渠道。

## 2.取消/关闭的机制
Thread类的 `stop()` 方法看上去就可以停止线程，但这个方法被标记为了过时，简单的说，我们不应该使用它，可以忽略它。

在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。

Thread类定义了如下关于中断的方法：`isInterrupted()`、`interrupt()`、`interrupted()`。这三个方法名字类似，比较容易混淆。isInterrupted()和interrupt()是实例方法，调用它们需要通过线程对象，interrupted()是静态方法，实际会调用Thread.currentThread()操作当前线程。 

每个线程都有一个标志位，表示该线程是否被中断了。
- isInterrupted：就是返回对应线程的中断标志位是否为true。
- interrupted：返回当前线程的中断标志位是否为true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用interrupted()，第一次返回的结果为true，第二次一般就是false (除非同时又发生了一次中断)。
- interrupt：表示中断对应的线程。

## 3.线程对中断的反应
interrupt()对线程的影响与线程的状态和在进行的IO操作有关，我们先主要考虑线程的状态：
- RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度
- WAITING/TIMED_WAITING：线程在等待某个条件或超时
- BLOCKED：线程在等待锁，试图进入同步块
- NEW/TERMINATED：线程还未启动或已结束

#### 3.1.RUNNABLE
如果线程在运行中，且没有执行IO操作，interrupt()只是会设置线程的中断标志位，没有任何其它作用。线程应该在运行过程中合适的位置检查中断标志位，比如说，如果主体代码是一个循环，可以在循环开始处进行检查。

#### 3.2.WAITING/TIMED_WAITING
线程执行 `join()`、`wait()` 会进入WAITING状态，执行`join(long millis)`、`wait(long timeout)`、`sleep(long millis)` 会进入TIMED_WAITING状态。在这些状态时，对线程对象调用interrupt()会使得该线程抛出InterruptedException，需要注意的是，抛出异常后，中断标志位会被清空，而不是被设置。

InterruptedException是一个受检异常，线程必须进行处理。捕获到InterruptedException，通常表示希望结束该线程，线程大概有两种处理方式：
- 向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理。
- 有些情况，不能向上传递异常，比如Thread的run方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用Thread的interrupt方法设置中断标志位，使得其他代码有办法知道它发生了中断。

#### 3.3.BLOCKED
如果线程在等待锁，对线程对象调用interrupt()只是会设置线程的中断标志位，线程依然会处于BLOCKED状态，也就是说，interrupt()并不能使一个在等待锁的线程真正"中断"。

在使用synchronized关键字获取锁的过程中不响应中断请求，这是synchronized的局限性。如果这对程序是一个问题，应该使用显式锁，它支持以响应中断的方式获取锁。

#### 3.4.NEW/TERMINATE
如果线程尚未启动(NEW)，或者已经结束(TERMINATED)，则调用interrupt()对它没有任何效果，中断标志位也不会被设置。

#### 3.5.IO操作
如果线程在等待IO操作，尤其是网络IO，则会有一些特殊的处理。
- 如果IO通道是可中断的，即实现了InterruptibleChannel接口，则线程的中断标志位会被设置，同时，线程会收到异常ClosedByInterruptException。
- 如果线程阻塞于Selector调用，则线程的中断标志位会被设置，同时，阻塞的调用会立即返回。

我们重点介绍另一种情况，InputStream的read调用，该操作是不可中断的，如果流中没有数据，read会阻塞 (但线程状态依然是RUNNABLE)，且不响应interrupt()，与synchronized类似，调用interrupt()只会设置线程的中断标志，而不会真正"中断"它。有一个办法可以中断read()调用，那就是调用流的close方法。

## 4.如何正确地取消/关闭线程
以上，我们可以看出，interrupt方法不一定会真正"中断"线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然的调用线程的interrupt方法，以为这样就能取消线程。

对于以线程提供服务的程序模块而言，它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用interrupt。

Java并发库的一些代码就提供了单独的取消/关闭方法，比如说，Future接口提供了 `cancel()` 方法以取消任务，再比如，ExecutorService提供了如下两个关闭方法：`shutdown()`、`shutdownNow()`。