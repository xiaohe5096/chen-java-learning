## 1.同时开始
同时开始，类似于运动员比赛，在听到比赛开始枪响后同时开始。在程序里，有一个主线程和N个子线程，每个子线程模拟一个运动员，主线程模拟裁判，它们协作的共享变量是一个开始信号。子线程应该等待开始信号被置为“开始”状态，主线程将开始信号置为“开始”状态后各个子线程才开始执行后续操作。

## 2.等待结束
#### 2.1.理解join
我们知道使用join方法可以让调用join的线程等待该线程结束，join实际上就是调用了wait，当线程运行结束的时候，Java系统调用notifyAll来通知。

#### 2.2.使用协作对象
使用join有时比较麻烦，需要主线程逐一等待每个子线程。这里可以使用协作对象，主线程与各个子线程协作的共享变量是一个数，这个数表示未完成的线程个数，初始值为子线程个数，主线程等待该值变为0，而每个子线程结束后都将该值减一，当减为0时调用notifyAll。它也可以应用于上面"同时开始"的场景，初始值设为1。

在Java中有一个专门的同步类CountDownLatch，在实际开发中应该使用它。

## 3.异步结果
在主从模式中，手工创建线程往往比较麻烦，一种常见的模式是异步调用，异步调用返回一个一般称为Promise或Future的对象，通过它可以获得最终的结果。Future与Thread之间协作的共享变量是 `thread.isDone()` ，Future的 `get()` 方法等待该条件成立，当线程执行任务结束后调用 `notifyAll()` 唤醒等待结果的线程。

Java中已经包含了一套完善的框架Executors，在实际开发中应该使用它。

## 4.集合点
各个线程先是分头行动，然后各自到达一个集合点，在集合点需要集齐所有线程，交换数据，然后再进行下一步动作。怎么表示这种协作呢？协作的共享变量依然是一个数，这个数表示未到集合点的线程个数，初始值为子线程个数，每个线程到达集合点后将该值减一，如果不为0，表示还有别的线程未到，进行等待，如果变为0，表示自己是最后一个到的，调用notifyAll唤醒所有线程。

Java中有一个专门的同步工具类CyclicBarrier，在实际开发中应该使用它。